<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercices de Respiration Guidés - Naval Group Toulon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23E50000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22s-8-4-8-10c0-4 4-8 8-8s8 4 8 8c0 6-8 10-8 10z'%3E%3C/path%3E%3Cpath d='M12 18a4 4 0 0 0 4-4c0-2-2-4-4-4s-4 2-4 4a4 4 0 0 0 4 4z'%3E%3C/path%3E%3C/svg%3E" type="image/svg+xml">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #001F4C; /* Bleu foncé Naval Group */
            color: #E0E0E0; /* Texte clair pour contraste */
        }
        .app-container {
            background-color: #002F6C; /* Bleu légèrement plus clair pour les conteneurs */
            border-left: 5px solid #E50000; /* Rouge accent Naval Group */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .app-title {
            color: #E50000; /* Rouge accent pour les titres principaux */
        }
        .btn-control {
            background-color: #E50000; /* Rouge accent */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-control:hover {
            background-color: #CC0000; /* Rouge plus foncé au survol */
        }
        .btn-control-alt {
            background-color: #003F8C; /* Bleu moyen pour les boutons alternatifs */
            color: #E0E0E0; /* Texte clair */
        }
        .btn-control-alt:hover {
            background-color: #004F9C; /* Bleu plus foncé au survol */
        }
        .btn-stop {
            background-color: #FF6666; /* Rouge plus clair pour le bouton d'arrêt */
            color: white;
        }
        .btn-stop:hover {
            background-color: #FF3333; /* Rouge vif au survol */
        }

        /* Canvas backgrounds */
        #breathingCircleCanvas, #squareBreathingCanvasContainer, #_478BreathingCanvas {
            background-color: #003F8C; /* Bleu moyen pour les fonds de canvas */
        }
        
        /* Specific canvas text/colors */
        #squareBreathingText {
            color: #E0E0E0; /* Texte clair pour le carré */
        }
        
        .instruction-text {
            color: #E50000; /* Rouge accent pour les instructions */
            min-height: 2rem; 
        }
        .timer-text {
            color: #E0E0E0; /* Texte clair pour les timers */
        }
        .cycle-counter-text {
            color: #E0E0E0; /* Texte clair pour les compteurs */
            font-size: 0.875rem; /* text-sm */
        }
        .info-section {
            background-color: #002F6C; /* Bleu légèrement plus clair pour les sections d'info */
            border: 1px solid #003F8C; /* Bordure bleu moyen */
            color: #E0E0E0; /* Texte clair */
        }
        .info-section h3 {
            color: #E50000; /* Rouge accent pour les titres d'info */
        }
        .info-section strong {
            color: #FFFFFF; /* Blanc pur pour les éléments importants */
        }

        /* Navigation Tabs */
        .tab-button {
            background-color: #003F8C; /* Bleu moyen pour les onglets inactifs */
            color: #E0E0E0; /* Texte clair */
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            font-weight: 600;
            transition: background-color 0.3s ease, color 0.3s ease;
            cursor: pointer;
        }
        .tab-button:hover {
            background-color: #004F9C; /* Bleu plus foncé au survol */
        }
        .tab-button.active {
            background-color: #001F4C; /* Fond de page pour l'onglet actif */
            color: #E50000; /* Rouge accent pour l'onglet actif */
            box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
            border-top: 3px solid #E50000;
            border-left: 1px solid #003F8C;
            border-right: 1px solid #003F8C;
        }
        .tab-content {
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: block; /* Shown when active */
        }

        /* Lung icon styling */
        .lung-icon {
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.5rem;
            width: 1.5em; /* Adjust size relative to font */
            height: 1.5em;
            stroke: #E50000; /* Red color from Naval Group palette */
            stroke-width: 2;
            fill: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6">

    <header class="mb-8 text-center">
        <h1 class="text-3xl sm:text-4xl font-bold app-title">
            <svg class="lung-icon" viewBox="0 0 24 24">
                <path d="M12 22s-8-4-8-10c0-4 4-8 8-8s8 4 8 8c0 6-8 10-8 10z"></path>
                <path d="M12 18a4 4 0 0 0 4-4c0-2-2-4-4-4s-4 2-4 4a4 4 0 0 0 4 4z"></path>
            </svg>
            Vos Outils de Respiration
        </h1>
        <p class="text-lg text-gray-300 mt-2">Retrouvez calme et équilibre avec ces exercices guidés.</p>
    </header>

    <div class="w-full max-w-4xl mb-8">
        <div class="flex justify-center mb-4">
            <button class="tab-button active" onclick="showTab('accueil')">Accueil</button>
            <button class="tab-button" onclick="showTab('coherence')">Cohérence Cardiaque</button>
            <button class="tab-button" onclick="showTab('carre')">Respiration Carrée</button>
            <button class="tab-button" onclick="showTab('478')">Technique 4-7-8</button>
        </div>

        <div id="accueil" class="tab-content active app-container p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-3 text-center text-red-500">Bienvenue sur votre espace de pratique respiratoire !</h2>
            <p class="text-base leading-relaxed mb-2">
                Cette page vous est proposée par le <strong class="font-semibold text-white">Service de Prévention et Santé au Travail de Naval Group Toulon</strong>, suite à l'information sur la gestion du stress animée par <strong class="font-semibold text-white">Fabienne ESPOSITO</strong> et <strong class="font-semibold text-white">Frédéric GENDRE</strong>. Elle vise à vous offrir des outils pratiques pour intégrer ces techniques dans votre quotidien.
            </p>
            <p class="text-base leading-relaxed mb-2">
                Vous trouverez ici trois outils simples et efficaces pour vous aider à cultiver le calme et la sérénité au quotidien :
            </p>
            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-3">
                <li><strong class="text-red-500">La Cohérence Cardiaque :</strong> Une pratique de 5 minutes pour réguler votre rythme cardiaque, apaiser votre système nerveux et réduire instantanément le stress.</li>
                <li><strong class="text-red-500">La Respiration Carrée :</strong> Un exercice en 4 temps (inspirer, retenir, expirer, retenir) pour améliorer votre concentration, votre gestion émotionnelle et votre équilibre intérieur.</li>
                <li><strong class="text-red-500">La Technique 4-7-8 :</strong> Une méthode simple pour favoriser la relaxation profonde et l'endormissement rapide.</li>
            </ul>
            <p class="text-base leading-relaxed">
                Prenez quelques instants pour vous, choisissez un exercice et laissez-vous guider en utilisant les onglets ci-dessus.
            </p>
        </div>

        <div id="coherence" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Cohérence Cardiaque</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">Harmonise ton rythme cardiaque pour un esprit apaisé.</p>
            
            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="coherenceAppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice (5 min)</h3>
                    <div class="text-center mb-4">
                        <canvas id="breathingCircleCanvas" width="200" height="200"></canvas>
                    </div>
                    <div id="coherenceInstruction" class="text-center text-xl font-semibold mb-2 instruction-text">Prêt ?</div>
                    <div id="coherenceTimer" class="text-center text-4xl font-bold mb-6 timer-text">05:00</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStopCoherence" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSoundCoherence" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la Cohérence Cardiaque ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            La Cohérence Cardiaque est un état d'équilibre physiologique où le cœur, le cerveau et la respiration fonctionnent en harmonie. Elle est obtenue en pratiquant une respiration rythmée à 6 cycles par minute (5 secondes à l'inspiration, 5 secondes à l'expiration). Cet état optimise les fonctions corporelles et mentales, réduisant le stress et favorisant le bien-être.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Réduction significative du stress et de l'anxiété.</li>
                            <li>Amélioration de la gestion émotionnelle.</li>
                            <li>Augmentation de la clarté mentale et de la concentration.</li>
                            <li>Meilleure régulation de la tension artérielle.</li>
                            <li>Renforcement du système immunitaire.</li>
                            <li>Amélioration de la qualité du sommeil.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            L'exercice est simple : inspire pendant 5 secondes, puis expire pendant 5 secondes. Répète ce cycle sans pause. L'application ci-contre te guide visuellement et auditivement pour maintenir ce rythme idéal.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la Cohérence Cardiaque une routine</h3>
                        <p class="text-base leading-relaxed">
                            Pour des effets durables, il est recommandé de pratiquer la Cohérence Cardiaque 3 fois par jour, pendant 5 minutes, idéalement le matin au lever, avant le déjeuner, et en fin de journée. Une pratique régulière ancre l'état de calme en toi.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div id="carre" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Respiration Carrée</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">Un exercice structuré pour la concentration et le calme.</p>

            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="squareAppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice (10 Cycles)</h3>
                    <div class="text-center mb-4">
                        <canvas id="squareBreathingCanvas" width="180" height="180"></canvas>
                        <div id="squareBreathingText">Prêt ?</div>
                    </div>
                    <div id="squareInstruction" class="text-center text-xl font-semibold mb-1 instruction-text">Prêt ? (4s par phase)</div>
                    <div id="squareCycleCounter" class="text-center text-sm mb-1 cycle-counter-text">Cycle : 0 / 10</div>
                    <div id="squarePhaseTimer" class="text-center text-4xl font-bold mb-6 timer-text">00:04</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStopSquare" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSoundSquare" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la Respiration Carrée ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            La Respiration Carrée (ou "Box Breathing") est une technique de respiration simple et puissante, souvent utilisée pour calmer le système nerveux, améliorer la concentration et réduire le stress. Elle consiste à diviser la respiration en quatre phases de durée égale : inspiration, rétention poumons pleins, expiration, et rétention poumons vides.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Réduit l'anxiété et le stress rapidement.</li>
                            <li>Améliore ta concentration et ta clarté mentale.</li>
                            <li>Aide à réguler tes émotions fortes.</li>
                            <li>Favorise un sentiment de calme et de contrôle.</li>
                            <li>Utile pour te préparer à des situations stressantes ou pour retrouver ton calme après.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Suis le guide visuel de l'application :
                            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4">
                                <li>Inspire par le nez pendant 4 secondes.</li>
                                <li>Retiens ton souffle (poumons pleins) pendant 4 secondes.</li>
                                <li>Expire lentement par la bouche pendant 4 secondes.</li>
                                <li>Retiens ton souffle (poumons vides) pendant 4 secondes.</li>
                            </ul>
                            Ceci constitue un cycle. Répète ce cycle pour le nombre de cycles souhaité (ici, 10 cycles).
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la Respiration Carrée une routine</h3>
                        <p class="text-base leading-relaxed">
                            La Respiration Carrée peut être pratiquée à tout moment de la journée, dès que tu ressens le besoin de te recentrer ou de gérer un pic de stress. Quelques cycles suffisent pour ressentir un apaisement. Intègre-la avant une réunion importante, pendant une pause, ou le soir pour faciliter l'endormissement.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <div id="478" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Technique 4-7-8</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">La clé d'un endormissement rapide et d'une relaxation profonde.</p>

            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="_478AppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice 4-7-8 (20 Cycles)</h3>
                    <div class="text-center mb-4">
                        <canvas id="_478BreathingCanvas" width="250" height="150"></canvas>
                    </div>
                    <div id="_478Instruction" class="text-center text-xl font-semibold mb-2 instruction-text">Prêt ?</div>
                    <div id="_478CycleCounter" class="text-center text-sm mb-1 cycle-counter-text">Cycle : 0 / 20</div>
                    <div id="_478PhaseTimer" class="text-center text-4xl font-bold mb-6 timer-text">00:00</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStop_478" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSound_478" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la technique 4-7-8 ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Développée par le Dr. Andrew Weil, la technique de respiration 4-7-8 est un puissant relaxant naturel pour le système nerveux. Elle est basée sur une ancienne pratique yogique et est conçue pour aider à s'endormir rapidement, à calmer l'anxiété et à gérer le stress.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Facilite l'endormissement rapide et améliore la qualité du sommeil.</li>
                            <li>Réduit l'anxiété et le stress.</li>
                            <li>Aide à gérer les envies (nourriture, tabac).</li>
                            <li>Calme le système nerveux en situations de stress aigu.</li>
                            <li>Favorise la relaxation profonde et le bien-être général.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Cette technique se déroule en 3 étapes, toutes réalisées avec la pointe de la langue placée contre le palais, juste derrière les incisives supérieures :
                            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4">
                                <li><strong>1. Expire complètement</strong> par la bouche en faisant un léger bruit "whoosh".</li>
                                <li><strong>2. Inspire</strong> silencieusement par le nez pendant <strong>4 secondes</strong>.</li>
                                <li><strong>3. Retiens</strong> ton souffle pendant <strong>7 secondes</strong>.</li>
                                <li><strong>4. Expire</strong> complètement par la bouche en faisant un bruit "whoosh" pendant <strong>8 secondes</strong>.</li>
                            </ul>
                            Ceci constitue un cycle. Répète pour 20 cycles ou jusqu'à l'endormissement.
                            L'application ci-contre te guidera visuellement et auditivement à travers chaque phase.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la 4-7-8 une routine</h3>
                        <p class="text-base leading-relaxed">
                            Pratique cette technique au moins deux fois par jour pour en ressentir les bienfaits. Elle est particulièrement efficace avant de dormir, mais peut aussi être utilisée pour calmer une crise d'anxiété, gérer la colère, ou simplement pour te détendre à tout moment de la journée.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="mt-8 text-center text-gray-400 text-sm">
        <p>&copy; 2024 Naval Group Toulon - Service de Prévention et Santé au Travail</p>
    </footer>

    <script>
        // --- Tab Switching Logic ---
        function showTab(tabId) {
            // Get all tab content elements
            const tabContents = document.querySelectorAll('.tab-content');
            // Hide all tab contents
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Get all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            // Deactivate all tab buttons
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Show the selected tab content
            document.getElementById(tabId).classList.add('active');
            // Activate the clicked tab button
            event.currentTarget.classList.add('active');

            // Stop any running exercises when switching tabs
            stopCoherenceExercise();
            stopSquareExercise();
            stop_478Exercise(); // Stop the new 4-7-8 exercise
        }

        // --- Common Audio Context Initialization ---
        let audioContextInitialized = false;
        async function initializeAudioContext() {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running' && !audioContextInitialized) {
                try {
                    await Tone.start();
                    console.log("AudioContext démarré par l'utilisateur.");
                    audioContextInitialized = true;
                } catch (e) {
                    console.error("Erreur au démarrage de Tone.context:", e);
                    audioContextInitialized = false; 
                }
            } else if (typeof Tone === 'undefined' && !audioContextInitialized) {
                console.warn("Tone.js n'est pas chargé, les sons ne fonctionneront pas.");
                audioContextInitialized = true; 
            } else {
                audioContextInitialized = true; 
            }
            return audioContextInitialized;
        }

        // --- Application de Cohérence Cardiaque ---
        const coherenceCanvas = document.getElementById('breathingCircleCanvas');
        const coherenceInstructionText = document.getElementById('coherenceInstruction');
        const coherenceTimerText = document.getElementById('coherenceTimer');
        const coherenceStartStopBtn = document.getElementById('startStopCoherence');
        const coherenceMuteBtn = document.getElementById('muteSoundCoherence');

        let isCoherenceRunning = false; 
        let inhaleSynthC, exhaleSynthC; 
        let animationIdC;
        let timerIntervalC;
        let soundEnabledC = true; 

        if (coherenceCanvas) {
            const ctxC = coherenceCanvas.getContext('2d');
            const baseRadiusC = coherenceCanvas.height / 2 * 0.6; 
            const maxRadiusC = coherenceCanvas.height / 2 * 0.85; 
            const minRadiusC = coherenceCanvas.height / 2 * 0.35; 
            let currentRadiusC = minRadiusC;
            let inhalingC = true;
            const totalTimeC = 300; 
            let remainingTimeC = totalTimeC;

            function setupCoherenceSounds() {
                if (typeof Tone !== 'undefined') {
                    inhaleSynthC = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.7, release: 0.5 }, volume: -28 }).toDestination(); 
                    exhaleSynthC = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.7, release: 0.5 }, volume: -28 }).toDestination(); 
                }
            }
            setupCoherenceSounds();

            function drawCoherenceCircle() {
                ctxC.clearRect(0, 0, coherenceCanvas.width, coherenceCanvas.height);
                ctxC.beginPath();
                ctxC.arc(coherenceCanvas.width / 2, coherenceCanvas.height / 2, currentRadiusC, 0, 2 * Math.PI);
                ctxC.fillStyle = inhalingC ? '#E50000' : '#CC0000'; /* Rouge Naval Group */
                ctxC.fill();
            }

            function updateCoherenceTimerDisplay() {
                const minutes = Math.floor(remainingTimeC / 60);
                const seconds = remainingTimeC % 60;
                coherenceTimerText.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            let phaseStartTimeC = 0;
            const phaseDurationC = 5000; 

            function animateCoherence(timestamp) {
                if (!isCoherenceRunning) return;
                if (!phaseStartTimeC) phaseStartTimeC = timestamp;
                const elapsedTimeInPhase = timestamp - phaseStartTimeC;

                if (inhalingC) {
                    currentRadiusC = minRadiusC + (maxRadiusC - minRadiusC) * (elapsedTimeInPhase / phaseDurationC);
                    if (elapsedTimeInPhase >= phaseDurationC) {
                        currentRadiusC = maxRadiusC;
                        inhalingC = false;
                        phaseStartTimeC = timestamp;
                        coherenceInstructionText.textContent = "Expire..."; // Changed from Expirez
                        if (soundEnabledC && exhaleSynthC && audioContextInitialized) exhaleSynthC.triggerAttackRelease("D4", "4.8s", Tone.now());
                    }
                } else {
                    currentRadiusC = maxRadiusC - (maxRadiusC - minRadiusC) * (elapsedTimeInPhase / phaseDurationC);
                    if (elapsedTimeInPhase >= phaseDurationC) {
                        currentRadiusC = minRadiusC;
                        inhalingC = true;
                        phaseStartTimeC = timestamp;
                        coherenceInstructionText.textContent = "Inspire..."; // Changed from Inspirez
                        if (soundEnabledC && inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerAttackRelease("G4", "4.8s", Tone.now());
                    }
                }
                currentRadiusC = Math.max(minRadiusC, Math.min(maxRadiusC, currentRadiusC));
                drawCoherenceCircle();
                animationIdC = requestAnimationFrame(animateCoherence);
            }

            async function startCoherenceExercise() {
                if (isCoherenceRunning) return;
                const audioReady = await initializeAudioContext();
                if (!audioReady && typeof Tone !== 'undefined' && soundEnabledC) { 
                     console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                }

                isCoherenceRunning = true;
                coherenceStartStopBtn.textContent = "Arrêter";
                coherenceStartStopBtn.classList.remove('btn-control');
                coherenceStartStopBtn.classList.add('btn-stop');
                remainingTimeC = totalTimeC;
                updateCoherenceTimerDisplay();
                inhalingC = true;
                currentRadiusC = minRadiusC;
                coherenceInstructionText.textContent = "Inspire..."; // Changed from Inspirez
                phaseStartTimeC = performance.now();
                if (soundEnabledC && inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerAttackRelease("G4", "4.8s", Tone.now());

                if(timerIntervalC) clearInterval(timerIntervalC);
                timerIntervalC = setInterval(() => {
                    if (!isCoherenceRunning) { clearInterval(timerIntervalC); return; }
                    remainingTimeC--;
                    updateCoherenceTimerDisplay();
                    if (remainingTimeC <= 0) {
                        stopCoherenceExercise();
                        coherenceInstructionText.textContent = "Terminé !";
                    }
                }, 1000);
                if(animationIdC) cancelAnimationFrame(animationIdC);
                animationIdC = requestAnimationFrame(animateCoherence);
            }

            window.stopCoherenceExercise = function() { 
                if (!isCoherenceRunning) return;
                isCoherenceRunning = false;
                coherenceStartStopBtn.textContent = "Démarrer";
                coherenceStartStopBtn.classList.add('btn-control');
                coherenceStartStopBtn.classList.remove('btn-stop');
                cancelAnimationFrame(animationIdC);
                clearInterval(timerIntervalC);
                coherenceInstructionText.textContent = "Prêt ?";
                currentRadiusC = minRadiusC;
                drawCoherenceCircle();
                if (inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerRelease(Tone.now() + 0.1);
                if (exhaleSynthC && audioContextInitialized) exhaleSynthC.triggerRelease(Tone.now() + 0.1);
            }

            coherenceStartStopBtn.addEventListener('click', () => {
                if (!isCoherenceRunning) startCoherenceExercise();
                else stopCoherenceExercise();
            });

            coherenceMuteBtn.addEventListener('click', () => {
                soundEnabledC = !soundEnabledC;
                coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) Tone.Destination.mute = !soundEnabledC;
                // Synchronize with other mute buttons
                if (squareMuteBtnEl) {
                    soundEnabledSq = soundEnabledC;
                    squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                }
                if (_478MuteBtn) {
                    _478SoundEnabled = soundEnabledC;
                    _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                }
            });
            drawCoherenceCircle();
            updateCoherenceTimerDisplay();
        }

        // --- Application de Respiration Carrée ---
        const squareCanvasEl = document.getElementById('squareBreathingCanvas');
        const squareInstructionEl = document.getElementById('squareInstruction');
        const squarePhaseTimerEl = document.getElementById('squarePhaseTimer');
        const squareStartStopBtnEl = document.getElementById('startStopSquare');
        const squareMuteBtnEl = document.getElementById('muteSoundSquare');
        const squareBreathingTextEl = document.getElementById('squareBreathingText');
        const squareCycleCounterEl = document.getElementById('squareCycleCounter');

        let isSquareRunning = false; 
        let inhaleSynthSq, exhaleSynthSq; 
        let animationIdSq;
        let soundEnabledSq = true; 

        if (squareCanvasEl) {
            const ctxS = squareCanvasEl.getContext('2d');
            const canvasSize = 180;
            const padding = 20;
            const squareSide = canvasSize - 2 * padding;
            const squareX = padding;
            const squareY = padding;
            const ballRadius = 8;
            
            let currentPhaseSq = 0; 
            const phaseDurationSq = 4; 
            let timeInPhaseSq = phaseDurationSq;
            let timerIntervalSq;
            let ballPos = { x: squareX, y: squareY };

            const totalCyclesSq = 10;
            let currentCycleSq = 0;

            // Changed to 2nd person singular
            const phaseTextsSq = ["Inspire", "Retiens", "Expire", "Retiens"];
            
            function setupSquareSounds() {
                if (typeof Tone !== 'undefined') {
                    inhaleSynthSq = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0.6, release: 0.8 }, volume: -30 }).toDestination();
                    exhaleSynthSq = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0.6, release: 0.8 }, volume: -30 }).toDestination();
                }
            }
            setupSquareSounds();

            function drawSquareAndBall() {
                ctxS.clearRect(0, 0, canvasSize, canvasSize);
                
                ctxS.strokeStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.lineWidth = 3;
                ctxS.strokeRect(squareX, squareY, squareSide, squareSide);

                ctxS.beginPath();
                ctxS.arc(ballPos.x, ballPos.y, ballRadius, 0, 2 * Math.PI);
                ctxS.fillStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.fill();
            }

            function updateSquarePhaseTimerDisplay() {
                squarePhaseTimerEl.textContent = `00:0${Math.max(0, Math.ceil(timeInPhaseSq))}`;
            }
            function updateSquareCycleCounterDisplay() {
                squareCycleCounterEl.textContent = `Cycle : ${currentCycleSq} / ${totalCyclesSq}`;
            }
            
            let lastTimestampSq = 0;
            let progressInPhase = 0; 

            function animateSquare(timestamp) {
                if (!isSquareRunning) return;
                if (!lastTimestampSq) lastTimestampSq = timestamp;

                const deltaTime = (timestamp - lastTimestampSq) / 1000; 
                lastTimestampSq = timestamp;
                
                timeInPhaseSq -= deltaTime;
                progressInPhase += deltaTime / phaseDurationSq;

                if (timeInPhaseSq <= 0) {
                    currentPhaseSq = (currentPhaseSq + 1) % 4;
                    if (currentPhaseSq === 0) { 
                        currentCycleSq++;
                        updateSquareCycleCounterDisplay();
                        if (currentCycleSq > totalCyclesSq) {
                            stopSquareExercise();
                            squareBreathingTextEl.textContent = "Terminé !";
                            squareInstructionEl.textContent = `${totalCyclesSq} cycles complétés.`;
                            return;
                        }
                    }
                    timeInPhaseSq = phaseDurationSq;
                    progressInPhase = 0; 
                    squareBreathingTextEl.textContent = phaseTextsSq[currentPhaseSq];
                    squareInstructionEl.textContent = `${phaseTextsSq[currentPhaseSq]} (${phaseDurationSq}s)`;

                    if (soundEnabledSq && audioContextInitialized) {
                        if (currentPhaseSq === 0 && inhaleSynthSq) { 
                            inhaleSynthSq.triggerAttackRelease("C4", `${phaseDurationSq - 0.3}s`, Tone.now());
                        } else if (currentPhaseSq === 2 && exhaleSynthSq) { 
                            exhaleSynthSq.triggerAttackRelease("G3", `${phaseDurationSq - 0.3}s`, Tone.now());
                        }
                    }
                }
                updateSquarePhaseTimerDisplay();

                switch (currentPhaseSq) {
                    case 0: 
                        ballPos.x = squareX + squareSide * progressInPhase;
                        ballPos.y = squareY;
                        break;
                    case 1: 
                        ballPos.x = squareX + squareSide;
                        ballPos.y = squareY + squareSide * progressInPhase;
                        break;
                    case 2: 
                        ballPos.x = squareX + squareSide * (1 - progressInPhase);
                        ballPos.y = squareY + squareSide;
                        break;
                    case 3: 
                        ballPos.x = squareX;
                        ballPos.y = squareY + squareSide * (1 - progressInPhase);
                        break;
                }
                ballPos.x = Math.max(squareX, Math.min(squareX + squareSide, ballPos.x));
                ballPos.y = Math.max(squareY, Math.min(squareY + squareSide, ballPos.y));

                drawSquareAndBall();
                animationIdSq = requestAnimationFrame(animateSquare);
            }

            async function startSquareExercise() {
                if (isSquareRunning) return;
                const audioReady = await initializeAudioContext();
                 if (!audioReady && typeof Tone !== 'undefined' && soundEnabledSq) {
                     console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                 }

                isSquareRunning = true;
                squareStartStopBtnEl.textContent = "Arrêter";
                squareStartStopBtnEl.classList.remove('btn-control');
                squareStartStopBtnEl.classList.add('btn-stop');
                
                currentCycleSq = 1; 
                updateSquareCycleCounterDisplay();
                currentPhaseSq = 0; 
                timeInPhaseSq = phaseDurationSq;
                progressInPhase = 0;
                ballPos = { x: squareX, y: squareY };
                squareBreathingTextEl.textContent = phaseTextsSq[currentPhaseSq];
                squareInstructionEl.textContent = `${phaseTextsSq[currentPhaseSq]} (${phaseDurationSq}s)`;

                if (soundEnabledSq && inhaleSynthSq && audioContextInitialized) inhaleSynthSq.triggerAttackRelease("C4", `${phaseDurationSq - 0.3}s`, Tone.now());

                lastTimestampSq = performance.now();
                if(animationIdSq) cancelAnimationFrame(animationIdSq);
                animationIdSq = requestAnimationFrame(animateSquare);
            }

            window.stopSquareExercise = function() { 
                if (!isSquareRunning) return;
                isSquareRunning = false;
                squareStartStopBtnEl.textContent = "Démarrer";
                squareStartStopBtnEl.classList.add('btn-control');
                squareStartStopBtnEl.classList.remove('btn-stop');
                cancelAnimationFrame(animationIdSq);
                squareInstructionEl.textContent = "Prêt ? (4s par phase)";
                squareBreathingTextEl.textContent = "Prêt ?";
                timeInPhaseSq = phaseDurationSq;
                currentPhaseSq = 0;
                currentCycleSq = 0; 
                updateSquareCycleCounterDisplay();
                ballPos = { x: squareX, y: squareY }; 
                updateSquarePhaseTimerDisplay();
                drawSquareAndBall(); 
                if (inhaleSynthSq && audioContextInitialized) inhaleSynthSq.triggerRelease(Tone.now() + 0.1);
                if (exhaleSynthSq && audioContextInitialized) exhaleSynthSq.triggerRelease(Tone.now() + 0.1);
            }

            squareStartStopBtnEl.addEventListener('click', () => {
                if (!isSquareRunning) startSquareExercise();
                else stopSquareExercise();
            });

            squareMuteBtnEl.addEventListener('click', () => {
                soundEnabledSq = !soundEnabledSq;
                squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) {
                    Tone.Destination.mute = !soundEnabledSq; 
                    // Synchronize with other mute buttons
                    if (coherenceMuteBtn) {
                        soundEnabledC = soundEnabledSq;
                        coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                    }
                    if (_478MuteBtn) {
                        _478SoundEnabled = soundEnabledSq;
                        _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                    }
                }
            });
            drawSquareAndBall();
            updateSquarePhaseTimerDisplay();
            updateSquareCycleCounterDisplay(); 
        }

        // --- Application de Respiration 4-7-8 ---
        const _478Canvas = document.getElementById('_478BreathingCanvas');
        const _478InstructionEl = document.getElementById('_478Instruction');
        const _478PhaseTimerEl = document.getElementById('_478PhaseTimer');
        const _478CycleCounterEl = document.getElementById('_478CycleCounter');
        const _478StartStopBtn = document.getElementById('startStop_478');
        const _478MuteBtn = document.getElementById('muteSound_478');

        let is_478Running = false;
        let _478InhaleSynth, _478HoldSynth, _478ExhaleSynth;
        let _478AnimationId;
        let _478SoundEnabled = true;

        if (_478Canvas) {
            const ctx_478 = _478Canvas.getContext('2d');
            const canvasWidth_478 = _478Canvas.width;
            const canvasHeight_478 = _478Canvas.height;
            const _478MinFontSize = 16; // Smallest font size for "Inspire" (end of Expire)
            const _478MaxFontSize = 60; // Largest font size for "Inspire" (end) and "Expire" (start)
            const _478HoldFontSize = _478MaxFontSize; // Fixed font size for "Retiens" - same as max
            const _478PulseAmplitude = 0.05; // How much the "Retiens" text pulses (e.g., 5% size change)
            const _478PulseFrequency = 4; // How many pulses per second for "Retiens" (e.g., 2 pulses per second)
            const _478TransitionDuration = 1.0; // Duration of the cross-fade in seconds (increased for more marked transition)

            let _478CurrentPhase = 0; // 0: Expire (initial), 1: Inspire, 2: Retiens (full), 3: Expire (empty)
            const _478PhaseDurations = [0, 4, 7, 8]; // Durations for (initial expire), inspire, hold, expire
            let _478TimeInPhase = _478PhaseDurations[1]; // Start with inspire duration
            
            const _478TotalCycles = 20;
            let _478CurrentCycle = 0;

            // Already in 2nd person singular
            const _478PhaseTexts = ["Prêt ?", "Inspire", "Retiens", "Expire"]; 
            
            // Variables for cross-fade
            let _478IsTransitioning = false;
            let _478TransitionStartTime = 0;
            let _478PreviousPhaseText = "";
            let _478PreviousPhaseFontSize = _478HoldFontSize; // Initialize with a sensible default

            function setup_478Sounds() {
                if (typeof Tone !== 'undefined') {
                    // Increased volume for better audibility, while remaining soft
                    _478InhaleSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.5, decay: 0.1, sustain: 0.5, release: 0.5 }, volume: -25 }).toDestination(); // Gentle rise
                    _478HoldSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 0.1 }, volume: -30 }).toDestination(); // Soft hum
                    _478ExhaleSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 0.5 }, volume: -25 }).toDestination(); // Gentle fall
                }
            }
            setup_478Sounds();

            function draw_478Text(text, fontSize, color = '#E0E0E0', alpha = 1) { /* Couleur de texte ajustée */
                ctx_478.clearRect(0, 0, canvasWidth_478, canvasHeight_478);
                ctx_478.save(); // Save current context state
                ctx_478.globalAlpha = alpha; // Apply alpha for fading
                ctx_478.font = `${fontSize}px 'Nunito', sans-serif`;
                ctx_478.textAlign = 'center';
                ctx_478.textBaseline = 'middle';
                ctx_478.fillStyle = color;
                ctx_478.fillText(text, canvasWidth_478 / 2, canvasHeight_478 / 2);
                ctx_478.restore(); // Restore context state (resets globalAlpha)
            }

            // Function to draw text for cross-fade (draws two texts with different alphas)
            function draw_478CrossFade(oldText, oldFontSize, newText, newFontSize, alphaOld, alphaNew, color = '#E0E0E0') { /* Couleur de texte ajustée */
                ctx_478.clearRect(0, 0, canvasWidth_478, canvasHeight_478);
                
                // Draw old text fading out
                if (alphaOld > 0) {
                    ctx_478.save();
                    ctx_478.globalAlpha = alphaOld;
                    ctx_478.font = `${oldFontSize}px 'Nunito', sans-serif`;
                    ctx_478.textAlign = 'center';
                    ctx_478.textBaseline = 'middle';
                    ctx_478.fillStyle = color;
                    ctx_478.fillText(oldText, canvasWidth_478 / 2, canvasHeight_478 / 2);
                    ctx_478.restore();
                }

                // Draw new text fading in
                if (alphaNew > 0) {
                    ctx_478.save();
                    ctx_478.globalAlpha = alphaNew;
                    ctx_478.font = `${newFontSize}px 'Nunito', sans-serif`;
                    ctx_478.textAlign = 'center';
                    ctx_478.textBaseline = 'middle';
                    ctx_478.fillStyle = color;
                    ctx_478.fillText(newText, canvasWidth_478 / 2, canvasHeight_478 / 2);
                    ctx_478.restore();
                }
            }

            function update_478PhaseTimerDisplay() {
                _478PhaseTimerEl.textContent = `00:${String(Math.max(0, Math.ceil(_478TimeInPhase))).padStart(2, '0')}`;
            }

            function update_478CycleCounterDisplay() {
                _478CycleCounterEl.textContent = `Cycle : ${_478CurrentCycle} / ${_478TotalCycles}`;
            }

            let _478LastTimestamp = 0;
            let _478ProgressInPhase = 0;

            function animate_478(timestamp) {
                if (!is_478Running) return;
                if (!_478LastTimestamp) _478LastTimestamp = timestamp;

                const deltaTime = (timestamp - _478LastTimestamp) / 1000;
                _478LastTimestamp = timestamp;
                
                // Update time in phase, even during transition
                _478TimeInPhase -= deltaTime;
                _478ProgressInPhase = 1 - (_478TimeInPhase / _478PhaseDurations[_478CurrentPhase]); 
                _478ProgressInPhase = Math.max(0, Math.min(1, _478ProgressInPhase)); // Clamp progress

                let currentText = _478PhaseTexts[_478CurrentPhase];
                let currentFontSize = _478HoldFontSize; 

                // Calculate font size based on phase
                if (_478CurrentPhase === 1) { // Inspire (4s) - text grows
                    currentFontSize = _478MinFontSize + (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                } else if (_478CurrentPhase === 2) { // Retiens (7s) - text pulses
                    const pulseScale = 1 + _478PulseAmplitude * Math.sin(timestamp * Math.PI * _478PulseFrequency / 1000);
                    currentFontSize = _478HoldFontSize * pulseScale;
                } else if (_478CurrentPhase === 3) { // Expire (8s) - text shrinks
                    currentFontSize = _478MaxFontSize - (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                }
                currentFontSize = Math.max(_478MinFontSize, Math.min(_478MaxFontSize, currentFontSize)); 

                // Check for phase change and initiate transition
                if (_478TimeInPhase <= 0 && !_478IsTransitioning) {
                    _478IsTransitioning = true;
                    _478TransitionStartTime = timestamp;
                    _478PreviousPhaseText = currentText; // Store current text
                    _478PreviousPhaseFontSize = currentFontSize; // Store current font size

                    // Advance to next phase immediately for logic, but visual will transition
                    _478CurrentPhase = (_478CurrentPhase + 1) % _478PhaseTexts.length;
                    if (_478CurrentPhase === 0) { // If we've completed a full cycle (after Expire)
                        _478CurrentCycle++;
                        update_478CycleCounterDisplay();
                        if (_478CurrentCycle > _478TotalCycles) {
                            stop_478Exercise();
                            _478InstructionEl.textContent = "Terminé !";
                            return;
                        }
                        // After a full cycle, the next phase is Inspire (index 1)
                        _478CurrentPhase = 1; 
                    }
                    _478TimeInPhase = _478PhaseDurations[_478CurrentPhase]; // Reset timer for the new phase
                    _478ProgressInPhase = 0; // Reset progress for the new phase
                    _478InstructionEl.textContent = `${_478PhaseTexts[_478CurrentPhase]} (${_478PhaseDurations[_478CurrentPhase]}s)`;

                    // Play sound for the new phase
                    if (_478SoundEnabled && audioContextInitialized) {
                        if (_478CurrentPhase === 1 && _478InhaleSynth) { // Inspire
                            _478InhaleSynth.triggerAttackRelease("C4", `${_478PhaseDurations[1] - 0.2}s`, Tone.now());
                        } else if (_478CurrentPhase === 2 && _478HoldSynth) { // Retiens
                            _478HoldSynth.triggerAttackRelease("G3", `${_478PhaseDurations[2] - 0.2}s`, Tone.now());
                        } else if (_478CurrentPhase === 3 && _478ExhaleSynth) { // Expire
                            _478ExhaleSynth.triggerAttackRelease("C3", `${_478PhaseDurations[3] - 0.2}s`, Tone.now());
                        }
                    }
                }

                // Handle drawing based on transition state
                if (_478IsTransitioning) {
                    const transitionElapsedTime = timestamp - _478TransitionStartTime;
                    const transitionProgress = Math.max(0, Math.min(1, transitionElapsedTime / _478TransitionDuration));
                    const alphaOld = 1 - transitionProgress;
                    const alphaNew = transitionProgress;

                    // Recalculate font size for the new text *during* the transition as well
                    let newTextCalculatedFontSize = _478HoldFontSize;
                    if (_478CurrentPhase === 1) { // Inspire
                        newTextCalculatedFontSize = _478MinFontSize + (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                    } else if (_478CurrentPhase === 2) { // Retiens (pulsing during transition too)
                        const pulseScale = 1 + _478PulseAmplitude * Math.sin(timestamp * Math.PI * _478PulseFrequency / 1000);
                        newTextCalculatedFontSize = _478HoldFontSize * pulseScale;
                    } else if (_478CurrentPhase === 3) { // Expire
                        newTextCalculatedFontSize = _478MaxFontSize - (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                    }
                    newTextCalculatedFontSize = Math.max(_478MinFontSize, Math.min(_478MaxFontSize, newTextCalculatedFontSize));

                    draw_478CrossFade(
                        _478PreviousPhaseText, _478PreviousPhaseFontSize,
                        _478PhaseTexts[_478CurrentPhase], newTextCalculatedFontSize,
                        alphaOld, alphaNew
                    );

                    if (transitionProgress >= 1) {
                        _478IsTransitioning = false;
                    }
                } else {
                    // Not transitioning, draw current phase text with full opacity
                    draw_478Text(currentText, currentFontSize);
                }
                
                update_478PhaseTimerDisplay();
                _478AnimationId = requestAnimationFrame(animate_478);
            }

            async function start_478Exercise() {
                if (is_478Running) return;
                const audioReady = await initializeAudioContext();
                if (!audioReady && typeof Tone !== 'undefined' && _478SoundEnabled) {
                    console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                }

                is_478Running = true;
                _478StartStopBtn.textContent = "Arrêter";
                _478StartStopBtn.classList.remove('btn-control');
                _478StartStopBtn.classList.add('btn-stop');
                
                _478CurrentCycle = 1;
                update_478CycleCounterDisplay();
                // Start with the "Inspire" phase (index 1 in _478PhaseTexts and _478PhaseDurations)
                _478CurrentPhase = 1; 
                _478TimeInPhase = _478PhaseDurations[_478CurrentPhase];
                _478ProgressInPhase = 0;
                _478IsTransitioning = false; // Ensure no lingering transition state

                _478InstructionEl.textContent = `${_478PhaseTexts[_478CurrentPhase]} (${_478PhaseDurations[_478CurrentPhase]}s)`;
                update_478PhaseTimerDisplay();
                
                // Play initial inhale sound
                if (_478SoundEnabled && _478InhaleSynth && audioContextInitialized) _478InhaleSynth.triggerAttackRelease("C4", `${_478PhaseDurations[1] - 0.2}s`, Tone.now());

                _478LastTimestamp = performance.now();
                if(_478AnimationId) cancelAnimationFrame(_478AnimationId);
                _478AnimationId = requestAnimationFrame(animate_478);
            }

            window.stop_478Exercise = function() {
                if (!is_478Running) return;
                is_478Running = false;
                _478StartStopBtn.textContent = "Démarrer";
                _478StartStopBtn.classList.add('btn-control');
                _478StartStopBtn.classList.remove('btn-stop');
                cancelAnimationFrame(_478AnimationId);
                _478InstructionEl.textContent = "Prêt ?";
                _478CurrentPhase = 0; // Reset to initial "Prêt ?" state
                _478CurrentCycle = 0;
                update_478CycleCounterDisplay();
                _478TimeInPhase = _478PhaseDurations[1]; // Reset timer for next start
                update_478PhaseTimerDisplay();
                draw_478Text("Prêt ?", _478HoldFontSize, '#E0E0E0'); // Draw initial "Prêt ?" text with hold font size
                if (_478InhaleSynth && audioContextInitialized) _478InhaleSynth.triggerRelease(Tone.now() + 0.1);
                if (_478HoldSynth && audioContextInitialized) _478HoldSynth.triggerRelease(Tone.now() + 0.1);
                if (_478ExhaleSynth && audioContextInitialized) _478ExhaleSynth.triggerRelease(Tone.now() + 0.1);

                // Reset transition state variables
                _478IsTransitioning = false;
                _478TransitionStartTime = 0;
                _478PreviousPhaseText = "";
                _478PreviousPhaseFontSize = _478HoldFontSize;
            }

            _478StartStopBtn.addEventListener('click', () => {
                if (!is_478Running) start_478Exercise();
                else stop_478Exercise();
            });

            _478MuteBtn.addEventListener('click', () => {
                _478SoundEnabled = !_478SoundEnabled;
                _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) {
                    Tone.Destination.mute = !_478SoundEnabled;
                    // Synchronize with other mute buttons
                    if (coherenceMuteBtn) {
                        soundEnabledC = _478SoundEnabled;
                        coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                    }
                    if (squareMuteBtnEl) {
                        soundEnabledSq = _478SoundEnabled;
                        squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                    }
                }
            });
            draw_478Text("Prêt ?", _478HoldFontSize, '#E0E0E0'); // Initial draw
            update_478PhaseTimerDisplay();
            update_478CycleCounterDisplay(); 
        }

        // Initialize with accueil tab shown
        document.addEventListener('DOMContentLoaded', () => {
            showTab('accueil');
        });
    </script>
</body>
</html>