<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Exercices de Respiration Guidés - Naval Group Toulon</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Nunito:wght@300;400;600;700;800&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.js"></script>
    <!-- Favicon pour les poumons -->
    <link rel="icon" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='%23E50000' stroke-width='2' stroke-linecap='round' stroke-linejoin='round'%3E%3Cpath d='M12 22s-8-4-8-10c0-4 4-8 8-8s8 4 8 8c0 6-8 10-8 10z'%3E%3C/path%3E%3Cpath d='M12 18a4 4 0 0 0 4-4c0-2-2-4-4-4s-4 2-4 4a4 4 0 0 0 4 4z'%3E%3C/path%3E%3C/svg%3E" type="image/svg+xml">
    <style>
        body {
            font-family: 'Nunito', sans-serif;
            background-color: #001F4C; /* Bleu foncé Naval Group */
            color: #E0E0E0; /* Texte clair pour contraste */
        }
        .app-container {
            background-color: #002F6C; /* Bleu légèrement plus clair pour les conteneurs */
            border-left: 5px solid #E50000; /* Rouge accent Naval Group */
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.2), 0 4px 6px -2px rgba(0, 0, 0, 0.1);
        }
        .app-title {
            color: #E50000; /* Rouge accent pour les titres principaux */
        }
        .btn-control {
            background-color: #E50000; /* Rouge accent */
            color: white;
            transition: background-color 0.3s ease;
        }
        .btn-control:hover {
            background-color: #CC0000; /* Rouge plus foncé au survol */
        }
        .btn-control-alt {
            background-color: #003F8C; /* Bleu moyen pour les boutons alternatifs */
            color: #E0E0E0; /* Texte clair */
        }
        .btn-control-alt:hover {
            background-color: #004F9C; /* Bleu plus foncé au survol */
        }
        .btn-stop {
            background-color: #FF6666; /* Rouge plus clair pour le bouton d'arrêt */
            color: white;
        }
        .btn-stop:hover {
            background-color: #dc2626; /* Rouge vif au survol */
        }

        /* Canvas backgrounds */
        #breathingCircleCanvas, #squareBreathingCanvasContainer, #_478BreathingCanvas {
            background-color: #003F8C; /* Bleu moyen pour les fonds de canvas */
        }
        
        /* Specific canvas text/colors */
        /* Removed #squareBreathingText as it's now drawn on canvas */
        
        .instruction-text {
            color: #E50000; /* Rouge accent pour les instructions */
            min-height: 2rem; 
        }
        .timer-text {
            color: #E0E0E0; /* Texte clair pour les timers */
        }
        .cycle-counter-text {
            color: #E0E0E0; /* Texte clair pour les compteurs */
            font-size: 0.875rem; /* text-sm */
        }
        .info-section {
            background-color: #002F6C; /* Bleu légèrement plus clair pour les sections d'info */
            border: 1px solid #003F8C; /* Bordure bleu moyen */
            color: #E0E0E0; /* Texte clair */
        }
        .info-section h3 {
            color: #E50000; /* Rouge accent pour les titres d'info */
        }
        .info-section strong {
            color: #FFFFFF; /* Blanc pur pour les éléments importants */
        }

        /* Navigation Tabs */
        .tab-button {
            background-color: #003F8C; /* Bleu moyen pour les onglets inactifs */
            color: #E0E0E0; /* Texte clair */
            padding: 0.75rem 1.5rem;
            border-radius: 0.5rem 0.5rem 0 0;
            font-weight: 600;
            transition: background-color 0.3s ease, color 0.3s ease;
            cursor: pointer;
        }
        .tab-button:hover {
            background-color: #004F9C; /* Bleu plus foncé au survol */
        }
        .tab-button.active {
            background-color: #001F4C; /* Fond de page pour l'onglet actif */
            color: #E50000; /* Rouge accent pour l'onglet actif */
            box-shadow: 0 -2px 5px rgba(0,0,0,0.2);
            border-top: 3px solid #E50000;
            border-left: 1px solid #003F8C;
            border-right: 1px solid #003F8C;
        }
        .tab-content {
            display: none; /* Hidden by default */
        }
        .tab-content.active {
            display: block; /* Shown when active */
        }

        /* Lung icon styling */
        .lung-icon {
            display: inline-block;
            vertical-align: middle;
            margin-right: 0.5rem;
            width: 1.5em; /* Adjust size relative to font */
            height: 1.5em;
            stroke: #E50000; /* Red color from Naval Group palette */
            stroke-width: 2;
            fill: none;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center p-4 sm:p-6">

    <header class="mb-8 text-center">
        <h1 class="text-3xl sm:text-4xl font-bold app-title">
            <svg class="lung-icon" viewBox="0 0 24 24">
                <path d="M12 22s-8-4-8-10c0-4 4-8 8-8s8 4 8 8c0 6-8 10-8 10z"></path>
                <path d="M12 18a4 4 0 0 0 4-4c0-2-2-4-4-4s-4 2-4 4a4 4 0 0 0 4 4z"></path>
            </svg>
            Vos Outils de Respiration
        </h1>
        <p class="text-lg text-gray-300 mt-2">Retrouve calme et équilibre avec ces exercices guidés.</p>
    </header>

    <div class="w-full max-w-4xl mb-8">
        <div class="flex justify-center mb-4">
            <button class="tab-button active" onclick="showTab('accueil')">Accueil</button>
            <button class="tab-button" onclick="showTab('coherence')">Cohérence Cardiaque</button>
            <button class="tab-button" onclick="showTab('carre')">Respiration Carrée</button>
            <button class="tab-button" onclick="showTab('478')">Technique 4-7-8</button>
        </div>

        <!-- Accueil Section -->
        <div id="accueil" class="tab-content active app-container p-6 rounded-lg shadow-md">
            <h2 class="text-xl font-semibold mb-3 text-center text-red-500">Bienvenue sur ton espace de pratique respiratoire !</h2>
            <p class="text-base leading-relaxed mb-2">
                Cette page t'est proposée par le <strong class="font-semibold text-white">Service de Prévention et Santé au Travail de Naval Group Toulon</strong>, suite à l'information sur la gestion du stress animée par <strong class="font-semibold text-white">Fabienne ESPOSITO</strong> et <strong class="font-semibold text-white">Frédéric GENDRE</strong>. Elle vise à t'offrir des outils pratiques pour intégrer ces techniques dans ton quotidien.
            </p>
            <p class="text-base leading-relaxed mb-2">
                Tu trouveras ici trois outils simples et efficaces pour t'aider à cultiver le calme et la sérénité au quotidien :
            </p>
            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-3">
                <li><strong class="text-red-500">La Cohérence Cardiaque :</strong> Une pratique de 5 minutes pour réguler ton rythme cardiaque, apaiser ton système nerveux et réduire instantanément le stress.</li>
                <li><strong class="text-red-500">La Respiration Carrée :</strong> Un exercice en 4 temps (inspire, retiens, expire, retiens) pour améliorer ta concentration, ta gestion émotionnelle et ton équilibre intérieur.</li>
                <li><strong class="text-red-500">La Technique 4-7-8 :</strong> Une méthode simple pour favoriser la relaxation profonde et l'endormissement rapide.</li>
            </ul>
            <p class="text-base leading-relaxed">
                Prends quelques instants pour toi, choisis un exercice et laisse-toi guider en utilisant les onglets ci-dessus.
            </p>
        </div>

        <!-- Cohérence Cardiaque Section -->
        <div id="coherence" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Cohérence Cardiaque</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">Harmonise ton rythme cardiaque pour un esprit apaisé.</p>
            
            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="coherenceAppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice (5 min)</h3>
                    <div class="text-center mb-4">
                        <canvas id="breathingCircleCanvas" width="200" height="200"></canvas>
                    </div>
                    <div id="coherenceInstruction" class="text-center text-xl font-semibold mb-2 instruction-text">Prêt ?</div>
                    <div id="coherenceTimer" class="text-center text-4xl font-bold mb-6 timer-text">05:00</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStopCoherence" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSoundCoherence" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la Cohérence Cardiaque ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            La Cohérence Cardiaque est un état d'équilibre physiologique où le cœur, le cerveau et la respiration fonctionnent en harmonie. Elle est obtenue en pratiquant une respiration rythmée à 6 cycles par minute (5 secondes à l'inspiration, 5 secondes à l'expiration). Cet état optimise les fonctions corporelles et mentales, réduisant le stress et favorisant le bien-être.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Réduction significative du stress et de l'anxiété.</li>
                            <li>Amélioration de la gestion émotionnelle.</li>
                            <li>Augmentation de la clarté mentale et de la concentration.</li>
                            <li>Meilleure régulation de la tension artérielle.</li>
                            <li>Renforcement du système immunitaire.</li>
                            <li>Amélioration de la qualité du sommeil.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            L'exercice est simple : inspire pendant 5 secondes, puis expire pendant 5 secondes. Répète ce cycle sans pause. L'application ci-contre te guide visuellement et auditivement pour maintenir ce rythme idéal.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la Cohérence Cardiaque une routine</h3>
                        <p class="text-base leading-relaxed">
                            Pour des effets durables, il est recommandé de pratiquer la Cohérence Cardiaque 3 fois par jour, pendant 5 minutes, idéalement le matin au lever, avant le déjeuner, et en fin de journée. Une pratique régulière ancre l'état de calme en toi.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- Respiration Carrée Section -->
        <div id="carre" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Respiration Carrée</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">Un exercice structuré pour la concentration et le calme.</p>

            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="squareAppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice (10 Cycles)</h3>
                    <div class="text-center mb-4">
                        <!-- Canvas for square breathing text animation -->
                        <canvas id="squareBreathingCanvas" width="180" height="180"></canvas>
                    </div>
                    <!-- Removed #squareBreathingText div -->
                    <div id="squareInstruction" class="text-center text-xl font-semibold mb-1 instruction-text">Prêt ? (4s par phase)</div>
                    <div id="squareCycleCounter" class="text-center text-sm mb-1 cycle-counter-text">Cycle : 0 / 10</div>
                    <div id="squarePhaseTimer" class="text-center text-4xl font-bold mb-6 timer-text">00:04</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStopSquare" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSoundSquare" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la Respiration Carrée ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            La Respiration Carrée (ou "Box Breathing") est une technique de respiration simple et puissante, souvent utilisée pour calmer le système nerveux, améliorer la concentration et réduire le stress. Elle consiste à diviser la respiration en quatre phases de durée égale : inspire, retiens, expire, et retiens.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Réduit l'anxiété et le stress rapidement.</li>
                            <li>Améliore ta concentration et ta clarté mentale.</li>
                            <li>Aide à réguler tes émotions fortes.</li>
                            <li>Favorise un sentiment de calme et de contrôle.</li>
                            <li>Utile pour te préparer à des situations stressantes ou pour retrouver ton calme après.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Suis le guide visuel de l'application :
                            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4">
                                <li>Inspire par le nez pendant 4 secondes.</li>
                                <li>Retiens ton souffle (poumons pleins) pendant 4 secondes.</li>
                                <li>Expire lentement par la bouche pendant 4 secondes.</li>
                                <li>Retiens ton souffle (poumons vides) pendant 4 secondes.</li>
                            </ul>
                            Ceci constitue un cycle. Répète ce cycle pour le nombre de cycles souhaité (ici, 10 cycles).
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la Respiration Carrée une routine</h3>
                        <p class="text-base leading-relaxed">
                            La Respiration Carrée peut être pratiquée à tout moment de la journée, dès que tu ressens le besoin de te recentrer ou de gérer un pic de stress. Quelques cycles suffisent pour ressentir un apaisement. Intègre-la avant une réunion importante, pendant une pause, ou le soir pour faciliter l'endormissement.
                        </p>
                    </div>
                </div>
            </div>
        </div>

        <!-- 4-7-8 Breathing Section -->
        <div id="478" class="tab-content app-container p-6 rounded-lg shadow-md">
            <h2 class="text-2xl font-bold text-center mb-6 app-title">Technique 4-7-8</h2>
            <p class="text-lg text-gray-300 mt-2 text-center">La clé d'un endormissement rapide et d'une relaxation profonde.</p>

            <div class="w-full max-w-4xl grid grid-cols-1 md:grid-cols-2 gap-8 mt-6">
                <div id="_478AppContainer" class="app-container p-6 rounded-xl">
                    <h3 class="text-xl font-bold text-center mb-6 app-title">Ton Exercice 4-7-8 (20 Cycles)</h3>
                    <div class="text-center mb-4">
                        <canvas id="_478BreathingCanvas" width="250" height="150"></canvas>
                    </div>
                    <div id="_478Instruction" class="text-center text-xl font-semibold mb-2 instruction-text">Prêt ?</div>
                    <div id="_478CycleCounter" class="text-center text-sm mb-1 cycle-counter-text">Cycle : 0 / 20</div>
                    <div id="_478PhaseTimer" class="text-center text-4xl font-bold mb-6 timer-text">00:00</div>
                    <div class="flex flex-col sm:flex-row justify-center space-y-3 sm:space-y-0 sm:space-x-4">
                        <button id="startStop_478" class="btn-control py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Démarrer</button>
                        <button id="muteSound_478" class="btn-control-alt py-2 px-6 rounded-lg font-semibold w-full sm:w-auto">Son On</button>
                    </div>
                </div>

                <div class="info-section p-6 rounded-lg shadow-md flex flex-col justify-between">
                    <div>
                        <h3 class="text-xl font-semibold mb-3 text-red-500">Qu'est-ce que la technique 4-7-8 ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Développée par le Dr. Andrew Weil, la technique de respiration 4-7-8 est un puissant relaxant naturel pour le système nerveux. Elle est basée sur une ancienne pratique yogique et est conçue pour aider à s'endormir rapidement, à calmer l'anxiété et à gérer le stress.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Les Bienfaits</h3>
                        <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4 mb-4">
                            <li>Facilite l'endormissement rapide et améliore la qualité du sommeil.</li>
                            <li>Réduit l'anxiété et le stress.</li>
                            <li>Aide à gérer les envies (nourriture, tabac).</li>
                            <li>Calme le système nerveux en situations de stress aigu.</li>
                            <li>Favorise la relaxation profonde et le bien-être général.</li>
                        </ul>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Comment pratiquer ?</h3>
                        <p class="text-base leading-relaxed mb-4">
                            Cette technique se déroule en 3 étapes, toutes réalisées avec la pointe de la langue placée contre le palais, juste derrière les incisives supérieures :
                            <ul class="list-disc list-inside space-y-1 text-base leading-relaxed pl-4">
                                <li><strong>1. Expire complètement</strong> par la bouche en faisant un léger bruit "whoosh".</li>
                                <li><strong>2. Inspire</strong> silencieusement par le nez pendant <strong>4 secondes</strong>.</li>
                                <li><strong>3. Retiens</strong> ton souffle pendant <strong>7 secondes</strong>.</li>
                                <li><strong>4. Expire</strong> complètement par la bouche en faisant un bruit "whoosh" pendant <strong>8 secondes</strong>.</li>
                            </ul>
                            Ceci constitue un cycle. Répète pour 20 cycles ou jusqu'à l'endormissement.
                            L'application ci-contre te guidera visuellement et auditivement à travers chaque phase.
                        </p>

                        <h3 class="text-xl font-semibold mb-3 text-red-500">Faire de la 4-7-8 une routine</h3>
                        <p class="text-base leading-relaxed">
                            Pratique cette technique au moins deux fois par jour pour en ressentir les bienfaits. Elle est particulièrement efficace avant de dormir, mais peut aussi être utilisée pour calmer une crise d'anxiété, gérer la colère, ou simplement pour te détendre à tout moment de la journée.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <footer class="mt-8 text-center text-gray-400 text-sm">
        <p>&copy; 2025 Naval Group Toulon - Service de Prévention et Santé au Travail</p>
    </footer>

    <script>
        // --- Tab Switching Logic ---
        function showTab(tabId) {
            // Get all tab content elements
            const tabContents = document.querySelectorAll('.tab-content');
            // Hide all tab contents
            tabContents.forEach(content => {
                content.classList.remove('active');
            });

            // Get all tab buttons
            const tabButtons = document.querySelectorAll('.tab-button');
            // Deactivate all tab buttons
            tabButtons.forEach(button => {
                button.classList.remove('active');
            });

            // Show the selected tab content
            document.getElementById(tabId).classList.add('active');
            // Activate the clicked tab button
            event.currentTarget.classList.add('active');

            // Stop any running exercises when switching tabs
            stopCoherenceExercise();
            stopSquareExercise();
            stop_478Exercise(); // Stop the new 4-7-8 exercise
        }

        // --- Common Audio Context Initialization ---
        let audioContextInitialized = false;
        async function initializeAudioContext() {
            if (typeof Tone !== 'undefined' && Tone.context.state !== 'running' && !audioContextInitialized) {
                try {
                    await Tone.start();
                    console.log("AudioContext démarré par l'utilisateur.");
                    audioContextInitialized = true;
                } catch (e) {
                    console.error("Erreur au démarrage de Tone.context:", e);
                    audioContextInitialized = false; 
                }
            } else if (typeof Tone === 'undefined' && !audioContextInitialized) {
                console.warn("Tone.js n'est pas chargé, les sons ne fonctionneront pas.");
                audioContextInitialized = true; 
            } else {
                audioContextInitialized = true; 
            }
            return audioContextInitialized;
        }

        // --- Application de Cohérence Cardiaque ---
        const coherenceCanvas = document.getElementById('breathingCircleCanvas');
        const coherenceInstructionText = document.getElementById('coherenceInstruction');
        const coherenceTimerText = document.getElementById('coherenceTimer');
        const coherenceStartStopBtn = document.getElementById('startStopCoherence');
        const coherenceMuteBtn = document.getElementById('muteSoundCoherence');

        let isCoherenceRunning = false; 
        let inhaleSynthC, exhaleSynthC; 
        let animationIdC;
        let timerIntervalC;
        let soundEnabledC = true; 

        // New variables for dots
        let totalDotsC = 30;
        let dotsRemainingC = totalDotsC;

        if (coherenceCanvas) {
            const ctxC = coherenceCanvas.getContext('2d');
            const baseRadiusC = coherenceCanvas.height / 2 * 0.6; 
            const maxRadiusC = coherenceCanvas.height / 2 * 0.85; 
            const minRadiusC = coherenceCanvas.height / 2 * 0.35; 
            let currentRadiusC = minRadiusC;
            let inhalingC = true;
            const totalTimeC = 300; 
            let remainingTimeC = totalTimeC;

            function setupCoherenceSounds() {
                if (typeof Tone !== 'undefined') {
                    inhaleSynthC = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.7, release: 0.5 }, volume: -28 }).toDestination(); 
                    exhaleSynthC = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.2, sustain: 0.7, release: 0.5 }, volume: -28 }).toDestination(); 
                }
            }
            setupCoherenceSounds();

            function drawCoherenceCircle() {
                ctxC.clearRect(0, 0, coherenceCanvas.width, coherenceCanvas.height);
                ctxC.beginPath();
                ctxC.arc(coherenceCanvas.width / 2, coherenceCanvas.height / 2, currentRadiusC, 0, 2 * Math.PI);
                ctxC.fillStyle = inhalingC ? '#E50000' : '#CC0000'; /* Rouge Naval Group */
                ctxC.fill();

                // Draw the 30 dots around the circle
                // Adjusted dotsOuterRadius to bring them closer to the circle and within canvas bounds
                const dotsOuterRadius = maxRadiusC + 5; // Closer to the main circle
                const dotRadius = 4; // Size of each dot
                const angleStep = (2 * Math.PI) / totalDotsC;

                for (let i = 0; i < dotsRemainingC; i++) {
                    const angle = i * angleStep;
                    const dotX = coherenceCanvas.width / 2 + dotsOuterRadius * Math.cos(angle);
                    const dotY = coherenceCanvas.height / 2 + dotsOuterRadius * Math.sin(angle);
                    ctxC.beginPath();
                    ctxC.arc(dotX, dotY, dotRadius, 0, 2 * Math.PI);
                    ctxC.fillStyle = '#E50000'; // Red color for dots
                    ctxC.fill();
                }
            }

            function updateCoherenceTimerDisplay() {
                const minutes = Math.floor(remainingTimeC / 60);
                const seconds = remainingTimeC % 60;
                coherenceTimerText.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
            }

            let phaseStartTimeC = 0;
            const phaseDurationC = 5000; 

            function animateCoherence(timestamp) {
                if (!isCoherenceRunning) return;
                if (!phaseStartTimeC) phaseStartTimeC = timestamp;
                const elapsedTimeInPhase = timestamp - phaseStartTimeC;

                if (inhalingC) {
                    currentRadiusC = minRadiusC + (maxRadiusC - minRadiusC) * (elapsedTimeInPhase / phaseDurationC);
                    if (elapsedTimeInPhase >= phaseDurationC) {
                        currentRadiusC = maxRadiusC;
                        inhalingC = false;
                        phaseStartTimeC = timestamp;
                        coherenceInstructionText.textContent = "Expire..."; // Changed from Expirez
                        if (soundEnabledC && exhaleSynthC && audioContextInitialized) exhaleSynthC.triggerAttackRelease("D4", "4.8s", Tone.now());
                    }
                } else {
                    currentRadiusC = maxRadiusC - (maxRadiusC - minRadiusC) * (elapsedTimeInPhase / phaseDurationC);
                    if (elapsedTimeInPhase >= phaseDurationC) {
                        currentRadiusC = minRadiusC;
                        inhalingC = true;
                        phaseStartTimeC = timestamp;
                        coherenceInstructionText.textContent = "Inspire..."; // Changed from Inspirez
                        if (soundEnabledC && inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerAttackRelease("G4", "4.8s", Tone.now());
                    }
                }
                currentRadiusC = Math.max(minRadiusC, Math.min(maxRadiusC, currentRadiusC));
                drawCoherenceCircle();
                animationIdC = requestAnimationFrame(animateCoherence);
            }

            async function startCoherenceExercise() {
                if (isCoherenceRunning) return;
                const audioReady = await initializeAudioContext();
                if (!audioReady && typeof Tone !== 'undefined' && soundEnabledC) { 
                     console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                }

                isCoherenceRunning = true;
                coherenceStartStopBtn.textContent = "Arrêter";
                coherenceStartStopBtn.classList.remove('btn-control');
                coherenceStartStopBtn.classList.add('btn-stop');
                
                remainingTimeC = totalTimeC;
                dotsRemainingC = totalDotsC; // Reset dots on start
                drawCoherenceCircle(); // Draw all dots initially
                updateCoherenceTimerDisplay();
                
                inhalingC = true;
                currentRadiusC = minRadiusC;
                coherenceInstructionText.textContent = "Inspire..."; // Changed from Inspirez
                phaseStartTimeC = performance.now();
                if (soundEnabledC && inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerAttackRelease("G4", "4.8s", Tone.now());

                if(timerIntervalC) clearInterval(timerIntervalC);
                timerIntervalC = setInterval(() => {
                    if (!isCoherenceRunning) { clearInterval(timerIntervalC); return; }
                    remainingTimeC--;
                    updateCoherenceTimerDisplay();

                    // Remove a dot every 10 seconds (one cycle)
                    // A cycle is 10 seconds (5s inspire + 5s expire)
                    // totalTimeC = 300s (5 min) -> 30 cycles
                    // A dot should disappear after the first full cycle (10s elapsed, remainingTimeC = 290)
                    if (remainingTimeC % 10 === 0 && remainingTimeC < totalTimeC) {
                        dotsRemainingC--;
                        if (dotsRemainingC < 0) dotsRemainingC = 0; // Prevent negative
                        drawCoherenceCircle(); // Redraw with fewer dots
                    }

                    if (remainingTimeC <= 0) {
                        stopCoherenceExercise();
                        coherenceInstructionText.textContent = "Terminé !";
                        dotsRemainingC = 0; // Ensure all dots are gone at the end
                        drawCoherenceCircle(); // Final redraw
                    }
                }, 1000);
                if(animationIdC) cancelAnimationFrame(animationIdC);
                animationIdC = requestAnimationFrame(animateCoherence);
            }

            window.stopCoherenceExercise = function() { 
                if (!isCoherenceRunning) return;
                isCoherenceRunning = false;
                coherenceStartStopBtn.textContent = "Démarrer";
                coherenceStartStopBtn.classList.add('btn-control');
                coherenceStartStopBtn.classList.remove('btn-stop');
                cancelAnimationFrame(animationIdC);
                clearInterval(timerIntervalC);
                coherenceInstructionText.textContent = "Prêt ?";
                currentRadiusC = minRadiusC;
                dotsRemainingC = totalDotsC; // Reset dots on stop
                drawCoherenceCircle(); // Redraw with all dots
                if (inhaleSynthC && audioContextInitialized) inhaleSynthC.triggerRelease(Tone.now() + 0.1);
                if (exhaleSynthC && audioContextInitialized) exhaleSynthC.triggerRelease(Tone.now() + 0.1);
            }

            coherenceStartStopBtn.addEventListener('click', () => {
                if (!isCoherenceRunning) startCoherenceExercise();
                else stopCoherenceExercise();
            });

            coherenceMuteBtn.addEventListener('click', () => {
                soundEnabledC = !soundEnabledC;
                coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) Tone.Destination.mute = !soundEnabledC;
                // Synchronize with other mute buttons
                if (squareMuteBtnEl) {
                    soundEnabledSq = soundEnabledC;
                    squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                }
                if (_478MuteBtn) {
                    _478SoundEnabled = soundEnabledC;
                    _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                }
            });
            drawCoherenceCircle(); // Initial draw with all dots
            updateCoherenceTimerDisplay();
        }

        // --- Application de Respiration Carrée ---
        const squareCanvasEl = document.getElementById('squareBreathingCanvas');
        const squareInstructionEl = document.getElementById('squareInstruction');
        const squarePhaseTimerEl = document.getElementById('squarePhaseTimer');
        const squareStartStopBtnEl = document.getElementById('startStopSquare');
        const squareMuteBtnEl = document.getElementById('muteSoundSquare');
        // Removed squareBreathingTextEl as it's now drawn on canvas
        const squareCycleCounterEl = document.getElementById('squareCycleCounter');

        let isSquareRunning = false; 
        let inhaleSynthSq, exhaleSynthSq; 
        let animationIdSq;
        let soundEnabledSq = true; 

        // Canvas dimensions for square breathing
        const canvasSizeSq = 180; // Revert to original size
        const paddingSq = 20;
        const squareSideSq = canvasSizeSq - (2 * paddingSq); // Side length of the inner square
        const squareXS = paddingSq; // X position of the square's top-left corner
        const squareYS = paddingSq; // Y position of the square's top-left corner
        const ballRadiusSq = 8; // Radius of the moving ball

        // New variables for square breathing text animation
        const _squareMinFontSize = 16;
        let _squareMaxFontSize; // Will be calculated dynamically
        let _squareHoldFontSize;
        const _squarePulseAmplitude = 0.05;
        const _squarePulseFrequency = 4;
        const _squareTransitionDuration = 0.5; // Shorter transition for faster square rhythm

        let _squareIsTransitioning = false;
        let _squareTransitionStartTime = 0;
        let _squarePreviousPhaseText = "";
        let _squarePreviousPhaseFontSize;

        // Ball position variable
        let ballPosSq = { x: squareXS, y: squareYS }; // Initial ball position at top-left corner of the square

        if (squareCanvasEl) {
            const ctxS = squareCanvasEl.getContext('2d');
            // Set canvas dimensions explicitly in JS to ensure they match the HTML
            squareCanvasEl.width = canvasSizeSq;
            squareCanvasEl.height = canvasSizeSq;

            // Recalculate _squareMaxFontSize based on the new canvas size
            // Estimate max text width for "Retiens" (longest word)
            // A common ratio for text width to font size is around 0.6 to 0.7 for typical fonts.
            // Let's aim for the text to fit within 80% of the square side.
            const textFitRatioSq = 0.8;
            // Temporarily set a font to measure text
            ctxS.font = "60px 'Nunito', sans-serif"; // Use a large font for measurement
            const textWidthEstimate = ctxS.measureText("Retiens").width;
            const estimatedRatio = textWidthEstimate / 60; // Ratio of 60px text width to 60px font size

            _squareMaxFontSize = Math.floor((squareSideSq * textFitRatioSq) / estimatedRatio);
            _squareMaxFontSize = Math.min(_squareMaxFontSize, 60); // Cap at 60px to prevent excessively large text
            _squareHoldFontSize = _squareMaxFontSize;
            _squarePreviousPhaseFontSize = _squareHoldFontSize; // Initialize here

            let currentPhaseSq = 0; 
            const phaseDurationSq = 4; 
            let timeInPhaseSq = phaseDurationSq;
            
            const totalCyclesSq = 10;
            let currentCycleSq = 0;

            // Changed to 2nd person singular
            const phaseTextsSq = ["Prêt ?", "Inspire", "Retiens", "Expire", "Retiens"]; // "Prêt ?" for initial state
            // Durations for each phase (0 for "Prêt ?")
            const _squarePhaseDurations = [0, 4, 4, 4, 4];
            
            function setupSquareSounds() {
                if (typeof Tone !== 'undefined') {
                    inhaleSynthSq = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0.6, release: 0.8 }, volume: -30 }).toDestination();
                    exhaleSynthSq = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.2, decay: 0.3, sustain: 0.6, release: 0.8 }, volume: -30 }).toDestination();
                }
            }
            setupSquareSounds();

            function drawSquareAndText(text, fontSize, color = '#E0E0E0', alpha = 1) {
                ctxS.clearRect(0, 0, canvasSizeSq, canvasSizeSq); // Clear the entire canvas
                
                // Draw the square outline
                ctxS.strokeStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.lineWidth = 3;
                ctxS.strokeRect(squareXS, squareYS, squareSideSq, squareSideSq);

                // Draw the text
                ctxS.save();
                ctxS.globalAlpha = alpha;
                ctxS.font = `${fontSize}px 'Nunito', sans-serif`;
                ctxS.textAlign = 'center';
                ctxS.textBaseline = 'middle';
                ctxS.fillStyle = color;
                ctxS.fillText(text, canvasSizeSq / 2, canvasSizeSq / 2);
                ctxS.restore();

                // Draw the ball
                ctxS.beginPath();
                ctxS.arc(ballPosSq.x, ballPosSq.y, ballRadiusSq, 0, 2 * Math.PI);
                ctxS.fillStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.fill();
            }

            function draw_squareCrossFade(oldText, oldFontSize, newText, newFontSize, alphaOld, alphaNew, color = '#E0E0E0') {
                ctxS.clearRect(0, 0, canvasSizeSq, canvasSizeSq); // Clear the entire canvas

                // Draw the square outline
                ctxS.strokeStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.lineWidth = 3;
                ctxS.strokeRect(squareXS, squareYS, squareSideSq, squareSideSq);
                
                // Draw old text fading out
                if (alphaOld > 0) {
                    ctxS.save();
                    ctxS.globalAlpha = alphaOld;
                    ctxS.font = `${oldFontSize}px 'Nunito', sans-serif`;
                    ctxS.textAlign = 'center';
                    ctxS.textBaseline = 'middle';
                    ctxS.fillStyle = color;
                    ctxS.fillText(oldText, canvasSizeSq / 2, canvasSizeSq / 2);
                    ctxS.restore();
                }

                // Draw new text fading in
                if (alphaNew > 0) {
                    ctxS.save();
                    ctxS.globalAlpha = alphaNew;
                    ctxS.font = `${newFontSize}px 'Nunito', sans-serif`;
                    ctxS.textAlign = 'center';
                    ctxS.textBaseline = 'middle';
                    ctxS.fillStyle = color;
                    ctxS.fillText(newText, canvasSizeSq / 2, canvasSizeSq / 2);
                    ctxS.restore();
                }

                // Draw the ball during transition
                ctxS.beginPath();
                ctxS.arc(ballPosSq.x, ballPosSq.y, ballRadiusSq, 0, 2 * Math.PI);
                ctxS.fillStyle = '#E50000'; /* Rouge Naval Group */
                ctxS.fill();
            }

            function updateSquarePhaseTimerDisplay() {
                squarePhaseTimerEl.textContent = `00:0${Math.max(0, Math.ceil(timeInPhaseSq))}`;
            }
            function updateSquareCycleCounterDisplay() {
                squareCycleCounterEl.textContent = `Cycle : ${currentCycleSq} / ${totalCyclesSq}`;
            }
            
            let lastTimestampSq = 0;
            let progressInPhase = 0; 

            function animateSquare(timestamp) {
                if (!isSquareRunning) return;
                if (!lastTimestampSq) lastTimestampSq = timestamp;

                const deltaTime = (timestamp - lastTimestampSq) / 1000; 
                lastTimestampSq = timestamp;
                
                timeInPhaseSq -= deltaTime;
                progressInPhase = 1 - (timeInPhaseSq / _squarePhaseDurations[currentPhaseSq]); 
                progressInPhase = Math.max(0, Math.min(1, progressInPhase));

                let currentText = phaseTextsSq[currentPhaseSq];
                let currentFontSize = _squareHoldFontSize; 

                // Calculate font size based on phase
                if (currentPhaseSq === 1) { // Inspire (4s) - text grows
                    currentFontSize = _squareMinFontSize + (_squareMaxFontSize - _squareMinFontSize) * progressInPhase;
                } else if (currentPhaseSq === 2 || currentPhaseSq === 4) { // Retiens (pulsing)
                    const pulseScale = 1 + _squarePulseAmplitude * Math.sin(timestamp * Math.PI * _squarePulseFrequency / 1000);
                    currentFontSize = _squareHoldFontSize * pulseScale;
                } else if (currentPhaseSq === 3) { // Expire (4s) - text shrinks
                    currentFontSize = _squareMaxFontSize - (_squareMaxFontSize - _squareMinFontSize) * progressInPhase;
                }
                currentFontSize = Math.max(_squareMinFontSize, Math.min(_squareMaxFontSize, currentFontSize)); 

                // Update ball position based on current phase and progress
                switch (currentPhaseSq) {
                    case 1: // Inspire (top edge, left to right)
                        ballPosSq.x = squareXS + squareSideSq * progressInPhase;
                        ballPosSq.y = squareYS;
                        break;
                    case 2: // Retiens (right edge, top to bottom)
                        ballPosSq.x = squareXS + squareSideSq;
                        ballPosSq.y = squareYS + squareSideSq * progressInPhase;
                        break;
                    case 3: // Expire (bottom edge, right to left)
                        ballPosSq.x = squareXS + squareSideSq * (1 - progressInPhase);
                        ballPosSq.y = squareYS + squareSideSq;
                        break;
                    case 4: // Retiens (left edge, bottom to top)
                        ballPosSq.x = squareXS;
                        ballPosSq.y = squareYS + squareSideSq * (1 - progressInPhase);
                        break;
                }
                // Clamp ball position to ensure it stays within the square boundaries
                ballPosSq.x = Math.max(squareXS, Math.min(squareXS + squareSideSq, ballPosSq.x));
                ballPosSq.y = Math.max(squareYS, Math.min(squareYS + squareSideSq, ballPosSq.y));

                // Check for phase change and initiate transition
                if (timeInPhaseSq <= 0 && !_squareIsTransitioning) {
                    _squareIsTransitioning = true;
                    _squareTransitionStartTime = timestamp;
                    _squarePreviousPhaseText = currentText; 
                    _squarePreviousPhaseFontSize = currentFontSize; 

                    // Advance to next phase immediately for logic, but visual will transition
                    currentPhaseSq = (currentPhaseSq + 1) % phaseTextsSq.length;
                    if (currentPhaseSq === 0) { // If we've completed a full square (after 2nd Retiens)
                        currentCycleSq++;
                        updateSquareCycleCounterDisplay();
                        if (currentCycleSq > totalCyclesSq) {
                            stopSquareExercise();
                            squareInstructionEl.textContent = "Terminé !";
                            return;
                        }
                        // After a full cycle, the next phase is Inspire (index 1)
                        currentPhaseSq = 1; 
                    }
                    timeInPhaseSq = _squarePhaseDurations[currentPhaseSq]; // Reset timer for the new phase
                    progressInPhase = 0; // Reset progress for the new phase
                    squareInstructionEl.textContent = `${phaseTextsSq[currentPhaseSq]} (${_squarePhaseDurations[currentPhaseSq]}s)`;

                    // Play sound for the new phase
                    if (soundEnabledSq && audioContextInitialized) {
                        if (currentPhaseSq === 1 && inhaleSynthSq) { // Inspire
                            inhaleSynthSq.triggerAttackRelease("C4", `${_squarePhaseDurations[1] - 0.2}s`, Tone.now());
                        } else if ((currentPhaseSq === 2 || currentPhaseSq === 4) && inhaleSynthSq) { // Retiens (using inhale synth for subtle hold sound)
                            inhaleSynthSq.triggerAttackRelease("G3", `${_squarePhaseDurations[currentPhaseSq] - 0.2}s`, Tone.now());
                        } else if (currentPhaseSq === 3 && exhaleSynthSq) { // Expire
                            exhaleSynthSq.triggerAttackRelease("C3", `${_squarePhaseDurations[3] - 0.2}s`, Tone.now());
                        }
                    }
                }

                // Handle drawing based on transition state
                if (_squareIsTransitioning) {
                    const transitionElapsedTime = timestamp - _squareTransitionStartTime;
                    const transitionProgress = Math.max(0, Math.min(1, transitionElapsedTime / _squareTransitionDuration));
                    const alphaOld = 1 - transitionProgress;
                    const alphaNew = transitionProgress;

                    // Recalculate font size for the new text *during* the transition as well
                    let newTextCalculatedFontSize = _squareHoldFontSize;
                    if (currentPhaseSq === 1) { // Inspire
                        newTextCalculatedFontSize = _squareMinFontSize + (_squareMaxFontSize - _squareMinFontSize) * progressInPhase;
                    } else if (currentPhaseSq === 2 || currentPhaseSq === 4) { // Retiens
                        const pulseScale = 1 + _squarePulseAmplitude * Math.sin(timestamp * Math.PI * _squarePulseFrequency / 1000);
                        newTextCalculatedFontSize = _squareHoldFontSize * pulseScale;
                    } else if (currentPhaseSq === 3) { // Expire
                        newTextCalculatedFontSize = _squareMaxFontSize - (_squareMaxFontSize - _squareMinFontSize) * progressInPhase;
                    }
                    newTextCalculatedFontSize = Math.max(_squareMinFontSize, Math.min(_squareMaxFontSize, newTextCalculatedFontSize));

                    draw_squareCrossFade(
                        _squarePreviousPhaseText, _squarePreviousPhaseFontSize,
                        phaseTextsSq[currentPhaseSq], newTextCalculatedFontSize,
                        alphaOld, alphaNew
                    );

                    if (transitionProgress >= 1) {
                        _squareIsTransitioning = false;
                    }
                } else {
                    // Not transitioning, draw current phase text with full opacity
                    drawSquareAndText(currentText, currentFontSize);
                }
                
                updateSquarePhaseTimerDisplay();
                animationIdSq = requestAnimationFrame(animateSquare);
            }

            async function startSquareExercise() {
                if (isSquareRunning) return;
                const audioReady = await initializeAudioContext();
                 if (!audioReady && typeof Tone !== 'undefined' && soundEnabledSq) {
                     console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                 }

                isSquareRunning = true;
                squareStartStopBtnEl.textContent = "Arrêter";
                squareStartStopBtnEl.classList.remove('btn-control');
                squareStartStopBtnEl.classList.add('btn-stop');
                
                currentCycleSq = 1; 
                updateSquareCycleCounterDisplay();
                currentPhaseSq = 1; // Start with "Inspire"
                timeInPhaseSq = phaseDurationSq;
                progressInPhase = 0;
                _squareIsTransitioning = false;

                squareInstructionEl.textContent = `${phaseTextsSq[currentPhaseSq]} (${_squarePhaseDurations[currentPhaseSq]}s)`;

                if (soundEnabledSq && inhaleSynthSq && audioContextInitialized) inhaleSynthSq.triggerAttackRelease("C4", `${_squarePhaseDurations[1] - 0.2}s`, Tone.now());

                lastTimestampSq = performance.now();
                if(animationIdSq) cancelAnimationFrame(animationIdSq);
                animationIdSq = requestAnimationFrame(animateSquare);
            }

            window.stopSquareExercise = function() { 
                if (!isSquareRunning) return;
                isSquareRunning = false;
                squareStartStopBtnEl.textContent = "Démarrer";
                squareStartStopBtnEl.classList.add('btn-control');
                squareStartStopBtnEl.classList.remove('btn-stop');
                cancelAnimationFrame(animationIdSq);
                squareInstructionEl.textContent = "Prêt ? (4s par phase)";
                currentPhaseSq = 0; // Reset to initial "Prêt ?" state
                currentCycleSq = 0; 
                updateSquareCycleCounterDisplay();
                timeInPhaseSq = phaseDurationSq;
                updateSquarePhaseTimerDisplay();
                drawSquareAndText("Prêt ?", _squareHoldFontSize, '#E0E0E0'); // Draw initial "Prêt ?" text
                if (inhaleSynthSq && audioContextInitialized) inhaleSynthSq.triggerRelease(Tone.now() + 0.1);
                if (exhaleSynthSq && audioContextInitialized) exhaleSynthSq.triggerRelease(Tone.now() + 0.1);

                _squareIsTransitioning = false;
                _squareTransitionStartTime = 0;
                _squarePreviousPhaseText = "";
                _squarePreviousPhaseFontSize = _squareHoldFontSize;
            }

            squareStartStopBtnEl.addEventListener('click', () => {
                if (!isSquareRunning) startSquareExercise();
                else stopSquareExercise();
            });

            squareMuteBtnEl.addEventListener('click', () => {
                soundEnabledSq = !soundEnabledSq;
                squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) {
                    Tone.Destination.mute = !soundEnabledSq; 
                    // Synchronize with other mute buttons
                    if (coherenceMuteBtn) {
                        soundEnabledC = soundEnabledSq;
                        coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                    }
                    if (_478MuteBtn) {
                        _478SoundEnabled = soundEnabledSq;
                        _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                    }
                }
            });
            drawSquareAndText("Prêt ?", _squareHoldFontSize, '#E0E0E0'); // Initial draw
            updateSquarePhaseTimerDisplay();
            updateSquareCycleCounterDisplay(); 
        }

        // --- Application de Respiration 4-7-8 ---
        const _478Canvas = document.getElementById('_478BreathingCanvas');
        const _478InstructionEl = document.getElementById('_478Instruction');
        const _478PhaseTimerEl = document.getElementById('_478PhaseTimer');
        const _478CycleCounterEl = document.getElementById('_478CycleCounter');
        const _478StartStopBtn = document.getElementById('startStop_478');
        const _478MuteBtn = document.getElementById('muteSound_478');

        let is_478Running = false;
        let _478InhaleSynth, _478HoldSynth, _478ExhaleSynth;
        let _478AnimationId;
        let _478SoundEnabled = true;

        if (_478Canvas) {
            const ctx_478 = _478Canvas.getContext('2d');
            const canvasWidth_478 = _478Canvas.width;
            const canvasHeight_478 = _478Canvas.height;
            const _478MinFontSize = 16; // Smallest font size for "Inspire" (end of Expire)
            const _478MaxFontSize = 60; // Largest font size for "Inspire" (end) and "Expire" (start)
            const _478HoldFontSize = _478MaxFontSize; // Fixed font size for "Retiens" - same as max
            const _478PulseAmplitude = 0.05; // How much the "Retiens" text pulses (e.g., 5% size change)
            const _478PulseFrequency = 4; // How many pulses per second for "Retiens" (e.g., 2 pulses per second)
            const _478TransitionDuration = 1.0; // Duration of the cross-fade in seconds (increased for more marked transition)

            let _478CurrentPhase = 0; // 0: Expire (initial), 1: Inspire, 2: Retiens (full), 3: Expire (empty)
            const _478PhaseDurations = [0, 4, 7, 8]; // Durations for (initial expire), inspire, hold, expire
            let _478TimeInPhase = _478PhaseDurations[1]; // Start with inspire duration
            
            const _478TotalCycles = 20;
            let _478CurrentCycle = 0;

            // Already in 2nd person singular
            const _478PhaseTexts = ["Prêt ?", "Inspire", "Retiens", "Expire"]; 
            
            // Variables for cross-fade
            let _478IsTransitioning = false;
            let _478TransitionStartTime = 0;
            let _478PreviousPhaseText = "";
            let _478PreviousPhaseFontSize = _478HoldFontSize; // Initialize with a sensible default

            function setup_478Sounds() {
                if (typeof Tone !== 'undefined') {
                    // Increased volume for better audibility, while remaining soft
                    _478InhaleSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.5, decay: 0.1, sustain: 0.5, release: 0.5 }, volume: -25 }).toDestination(); // Gentle rise
                    _478HoldSynth = new Tone.Synth({ oscillator: { type: 'triangle' }, envelope: { attack: 0.1, decay: 0.1, sustain: 0.8, release: 0.1 }, volume: -30 }).toDestination(); // Soft hum
                    _478ExhaleSynth = new Tone.Synth({ oscillator: { type: 'sine' }, envelope: { attack: 0.1, decay: 0.5, sustain: 0.1, release: 0.5 }, volume: -25 }).toDestination(); // Gentle fall
                }
            }
            setup_478Sounds();

            function draw_478Text(text, fontSize, color = '#E0E0E0', alpha = 1) { /* Couleur de texte ajustée */
                ctx_478.clearRect(0, 0, canvasWidth_478, canvasHeight_478);
                ctx_478.save(); // Save current context state
                ctx_478.globalAlpha = alpha; // Apply alpha for fading
                ctx_478.font = `${fontSize}px 'Nunito', sans-serif`;
                ctx_478.textAlign = 'center';
                ctx_478.textBaseline = 'middle';
                ctx_478.fillStyle = color;
                ctx_478.fillText(text, canvasWidth_478 / 2, canvasHeight_478 / 2);
                ctx_478.restore(); // Restore context state (resets globalAlpha)
            }

            // Function to draw text for cross-fade (draws two texts with different alphas)
            function draw_478CrossFade(oldText, oldFontSize, newText, newFontSize, alphaOld, alphaNew, color = '#E0E0E0') { /* Couleur de texte ajustée */
                ctx_478.clearRect(0, 0, canvasWidth_478, canvasHeight_478);
                
                // Draw old text fading out
                if (alphaOld > 0) {
                    ctx_478.save();
                    ctx_478.globalAlpha = alphaOld;
                    ctx_478.font = `${oldFontSize}px 'Nunito', sans-serif`;
                    ctx_478.textAlign = 'center';
                    ctx_478.textBaseline = 'middle';
                    ctx_478.fillStyle = color;
                    ctx_478.fillText(oldText, canvasWidth_478 / 2, canvasHeight_478 / 2);
                    ctx_478.restore();
                }

                // Draw new text fading in
                if (alphaNew > 0) {
                    ctx_478.save();
                    ctx_478.globalAlpha = alphaNew;
                    ctx_478.font = `${newFontSize}px 'Nunito', sans-serif`;
                    ctx_478.textAlign = 'center';
                    ctx_478.textBaseline = 'middle';
                    ctx_478.fillStyle = color;
                    ctx_478.fillText(newText, canvasWidth_478 / 2, canvasHeight_478 / 2);
                    ctx_478.restore();
                }
            }

            function update_478PhaseTimerDisplay() {
                _478PhaseTimerEl.textContent = `00:${String(Math.max(0, Math.ceil(_478TimeInPhase))).padStart(2, '0')}`;
            }

            function update_478CycleCounterDisplay() {
                _478CycleCounterEl.textContent = `Cycle : ${_478CurrentCycle} / ${_478TotalCycles}`;
            }

            let _478LastTimestamp = 0;
            let _478ProgressInPhase = 0;

            function animate_478(timestamp) {
                if (!is_478Running) return;
                if (!_478LastTimestamp) _478LastTimestamp = timestamp;

                const deltaTime = (timestamp - _478LastTimestamp) / 1000;
                _478LastTimestamp = timestamp;
                
                // Update time in phase, even during transition
                _478TimeInPhase -= deltaTime;
                _478ProgressInPhase = 1 - (_478TimeInPhase / _478PhaseDurations[_478CurrentPhase]); 
                _478ProgressInPhase = Math.max(0, Math.min(1, _478ProgressInPhase)); // Clamp progress

                let currentText = _478PhaseTexts[_478CurrentPhase];
                let currentFontSize = _478HoldFontSize; 

                // Calculate font size based on phase
                if (_478CurrentPhase === 1) { // Inspire (4s) - text grows
                    currentFontSize = _478MinFontSize + (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                } else if (_478CurrentPhase === 2) { // Retiens (7s) - text pulses
                    const pulseScale = 1 + _478PulseAmplitude * Math.sin(timestamp * Math.PI * _478PulseFrequency / 1000);
                    currentFontSize = _478HoldFontSize * pulseScale;
                } else if (_478CurrentPhase === 3) { // Expire (8s) - text shrinks
                    currentFontSize = _478MaxFontSize - (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                }
                currentFontSize = Math.max(_478MinFontSize, Math.min(_478MaxFontSize, currentFontSize)); 

                // Check for phase change and initiate transition
                if (_478TimeInPhase <= 0 && !_478IsTransitioning) {
                    _478IsTransitioning = true;
                    _478TransitionStartTime = timestamp;
                    _478PreviousPhaseText = currentText; // Store current text
                    _478PreviousPhaseFontSize = currentFontSize; // Store current font size

                    // Advance to next phase immediately for logic, but visual will transition
                    _478CurrentPhase = (_478CurrentPhase + 1) % _478PhaseTexts.length;
                    if (_478CurrentPhase === 0) { // If we've completed a full cycle (after Expire)
                        _478CurrentCycle++;
                        update_478CycleCounterDisplay();
                        if (_478CurrentCycle > _478TotalCycles) {
                            stop_478Exercise();
                            _478InstructionEl.textContent = "Terminé !";
                            return;
                        }
                        // After a full cycle, the next phase is Inspire (index 1)
                        _478CurrentPhase = 1; 
                    }
                    _478TimeInPhase = _478PhaseDurations[_478CurrentPhase]; // Reset timer for the new phase
                    _478ProgressInPhase = 0; // Reset progress for the new phase
                    _478InstructionEl.textContent = `${_478PhaseTexts[_478CurrentPhase]} (${_478PhaseDurations[_478CurrentPhase]}s)`;

                    // Play sound for the new phase
                    if (_478SoundEnabled && audioContextInitialized) {
                        if (_478CurrentPhase === 1 && _478InhaleSynth) { // Inspire
                            _478InhaleSynth.triggerAttackRelease("C4", `${_478PhaseDurations[1] - 0.2}s`, Tone.now());
                        } else if (_478CurrentPhase === 2 && _478HoldSynth) { // Retiens
                            _478HoldSynth.triggerAttackRelease("G3", `${_478PhaseDurations[2] - 0.2}s`, Tone.now());
                        } else if (_478CurrentPhase === 3 && _478ExhaleSynth) { // Expire
                            _478ExhaleSynth.triggerAttackRelease("C3", `${_478PhaseDurations[3] - 0.2}s`, Tone.now());
                        }
                    }
                }

                // Handle drawing based on transition state
                if (_478IsTransitioning) {
                    const transitionElapsedTime = timestamp - _478TransitionStartTime;
                    const transitionProgress = Math.max(0, Math.min(1, transitionElapsedTime / _478TransitionDuration));
                    const alphaOld = 1 - transitionProgress;
                    const alphaNew = transitionProgress;

                    // Recalculate font size for the new text *during* the transition as well
                    let newTextCalculatedFontSize = _478HoldFontSize;
                    if (_478CurrentPhase === 1) { // Inspire
                        newTextCalculatedFontSize = _478MinFontSize + (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                    } else if (_478CurrentPhase === 2) { // Retiens (pulsing during transition too)
                        const pulseScale = 1 + _478PulseAmplitude * Math.sin(timestamp * Math.PI * _478PulseFrequency / 1000);
                        newTextCalculatedFontSize = _478HoldFontSize * pulseScale;
                    } else if (_478CurrentPhase === 3) { // Expire
                        newTextCalculatedFontSize = _478MaxFontSize - (_478MaxFontSize - _478MinFontSize) * _478ProgressInPhase;
                    }
                    newTextCalculatedFontSize = Math.max(_478MinFontSize, Math.min(_478MaxFontSize, newTextCalculatedFontSize));

                    draw_478CrossFade(
                        _478PreviousPhaseText, _478PreviousPhaseFontSize,
                        _478PhaseTexts[_478CurrentPhase], newTextCalculatedFontSize,
                        alphaOld, alphaNew
                    );

                    if (transitionProgress >= 1) {
                        _478IsTransitioning = false;
                    }
                } else {
                    // Not transitioning, draw current phase text with full opacity
                    draw_478Text(currentText, currentFontSize);
                }
                
                update_478PhaseTimerDisplay();
                _478AnimationId = requestAnimationFrame(animate_478);
            }

            async function start_478Exercise() {
                if (is_478Running) return;
                const audioReady = await initializeAudioContext();
                if (!audioReady && typeof Tone !== 'undefined' && _478SoundEnabled) {
                    console.warn("Impossible de démarrer l'audio. L'exercice continuera sans son.");
                }

                is_478Running = true;
                _478StartStopBtn.textContent = "Arrêter";
                _478StartStopBtn.classList.remove('btn-control');
                _478StartStopBtn.classList.add('btn-stop');
                
                _478CurrentCycle = 1;
                update_478CycleCounterDisplay();
                // Start with the "Inspire" phase (index 1 in _478PhaseTexts and _478PhaseDurations)
                _478CurrentPhase = 1; 
                _478TimeInPhase = _478PhaseDurations[_478CurrentPhase];
                _478ProgressInPhase = 0;
                _478IsTransitioning = false; // Ensure no lingering transition state

                _478InstructionEl.textContent = `${_478PhaseTexts[_478CurrentPhase]} (${_478PhaseDurations[_478CurrentPhase]}s)`;
                update_478PhaseTimerDisplay();
                
                // Play initial inhale sound
                if (_478SoundEnabled && _478InhaleSynth && audioContextInitialized) _478InhaleSynth.triggerAttackRelease("C4", `${_478PhaseDurations[1] - 0.2}s`, Tone.now());

                _478LastTimestamp = performance.now();
                if(_478AnimationId) cancelAnimationFrame(_478AnimationId);
                _478AnimationId = requestAnimationFrame(animate_478);
            }

            window.stop_478Exercise = function() {
                if (!is_478Running) return;
                is_478Running = false;
                _478StartStopBtn.textContent = "Démarrer";
                _478StartStopBtn.classList.add('btn-control');
                _478StartStopBtn.classList.remove('btn-stop');
                cancelAnimationFrame(_478AnimationId);
                _478InstructionEl.textContent = "Prêt ?";
                _478CurrentPhase = 0; // Reset to initial "Prêt ?" state
                _478CurrentCycle = 0;
                update_478CycleCounterDisplay();
                _478TimeInPhase = _478PhaseDurations[1]; // Reset timer for next start
                update_478PhaseTimerDisplay();
                draw_478Text("Prêt ?", _478HoldFontSize, '#E0E0E0'); // Draw initial "Prêt ?" text with hold font size
                if (_478InhaleSynth && audioContextInitialized) _478InhaleSynth.triggerRelease(Tone.now() + 0.1);
                if (_478HoldSynth && audioContextInitialized) _478HoldSynth.triggerRelease(Tone.now() + 0.1);
                if (_478ExhaleSynth && audioContextInitialized) _478ExhaleSynth.triggerRelease(Tone.now() + 0.1);

                // Reset transition state variables
                _478IsTransitioning = false;
                _478TransitionStartTime = 0;
                _478PreviousPhaseText = "";
                _478PreviousPhaseFontSize = _478HoldFontSize;
            }

            _478StartStopBtn.addEventListener('click', () => {
                if (!is_478Running) start_478Exercise();
                else stop_478Exercise();
            });

            _478MuteBtn.addEventListener('click', () => {
                _478SoundEnabled = !_478SoundEnabled;
                _478MuteBtn.textContent = _478SoundEnabled ? "Son On" : "Son Off";
                if (typeof Tone !== 'undefined' && audioContextInitialized) {
                    Tone.Destination.mute = !_478SoundEnabled;
                    // Synchronize with other mute buttons
                    if (coherenceMuteBtn) {
                        soundEnabledC = _478SoundEnabled;
                        coherenceMuteBtn.textContent = soundEnabledC ? "Son On" : "Son Off";
                    }
                    if (squareMuteBtnEl) {
                        soundEnabledSq = _478SoundEnabled;
                        squareMuteBtnEl.textContent = soundEnabledSq ? "Son On" : "Son Off";
                    }
                }
            });
            draw_478Text("Prêt ?", _478HoldFontSize, '#E0E0E0'); // Initial draw
            update_478PhaseTimerDisplay();
            update_478CycleCounterDisplay(); 
        }

        // Initialize with accueil tab shown
        document.addEventListener('DOMContentLoaded', () => {
            showTab('accueil');
        });
    </script>
</body>
</html>